# README: Iris Compiler

Ayda Aricanli              ayda.aricanli@tufts.edu
Trevor Sullivan            trevor.sullivan@tufts.edu
Tim Valk                   timothy.valk@tufts.edu
Valerie Zhang              valerie.zhang@tufts.edu
Josh Kim                   joshua.kim634361@tufts.edu

# How to compile and execute

After downloading and unzipping the zip file, run 'make' in terminal. 
This will compile the compiler into an executable. Building Iris requires 
the same environment as MicroC.

# How to run test script

To run the testing script that runs the test suite, run './runtest.sh' 
in terminal. You can also run './runtest.sh $filename$' to run a specific test.
To keep intermediary files, run with the '-k' flag. The default options will 
run our test-hello-world.iris test, which is the only test in the suite right
now.

The test script diffs the output of the program against a golden standard 
provided in the test suite. All golden standard files contain the 
corresponding test name and terminates with '.out' as its name. The test 
script will not successfully compile a test program when it is incorrect.

# What is in the test suite

The test suite contains a single simple program that contains a single class 
"Main" with one public member function "main" that prints "Hello world!" with 
a newline after. It also contains the golden standard output file for that 
test. 

# What needs to be added

Most of our underlying structure has been implemented but we have much more 
semantic checking to be done. Right now, we are doing minimal checking and 
assuming that we are compiling a simple program that only contains the Main 
class and one method. The method also can only contain a function call to 
"print" in Olympus (one of our built-in classes), string literals, return 
statement, and integer literals. Moving forward, we will need to implement 
the rest of the cases to semantically check expressions, statements, etc. 
We will also need to handle encapsulation and inheritance.
