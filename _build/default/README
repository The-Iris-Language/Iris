# README: Iris Compiler

Ayda Aricanli              ayda.aricanli@tufts.edu
Trevor Sullivan            trevor.sullivan@tufts.edu
Tim Valk                   timothy.valk@tufts.edu
Valerie Zhang              valerie.zhang@tufts.edu
Josh Kim                   joshua.kim634361@tufts.edu

# How to compile and execute

After downloading and unzipping the zip file, run 'make' in terminal. 
This will compile the compiler into an executable. Building Iris requires 
the same environment as MicroC. 

You can run our test suite with `sh runtests`, and can see the output of a 
single test to terminal with `make test file=<FILENAME>`. You can run our demos
 with `make demo file=<FILENAME>`.

# How to run test script

Running the test script may require changing the LLC and LLI variables. 
"$(which llc)" was giving us trouble on our local machines.

To run the testing script that runs the test suite, run "sh runtests" in 
terminal. You can also run 'sh runtests tests/$filename$' to run a specific test.
To keep intermediary files, run with the '-k' flag. The default options will 
run our test-hello-world.iris test, which is the only test in the suite right
now.

The test script diffs the output of the program against a golden standard 
provided in the test suite. All golden standard files contain the 
corresponding test name and terminates with '.out' as its name. The test 
script will not successfully compile a test program when it is incorrect.

# What is in the test suite 
failure tests:

    assign-typ
    -- Assign a variable with an expression of a different type

    assign-undeclared 
    -- Assign an undeclared variable a value

    classvar-DNE
    -- Tests for failure of accessing a class var that DNE

    classvar-int
    -- Access a member variable from an int

    classvar-priv
    -- Access a class member that is private

    classvar-typ-assign
    -- Assign a class member with an expression of a different type

    decl-assign
    -- Tests for failure of declaration and assignment of mismatched types

    duplicate-classes
    -- Define two Mains 

    duplicate-other-classes
    -- Define two classes with the same name

    id-DNE
    -- Access an uninitialized variable

    local-decl
    -- Declare two variables of the same name and type in the same function
    
    local-dup
    -- Declare two variables of the same name of different types in the same function

    no-parent
    -- Tests for failure for undeclared Parent: Non-Main class

    opassign1
    -- Tests for failure binary operation and assignment on a non-int/float: float

    opassign2
    -- Tests for failure binary operation and assignment on a non-int/float: bool
    
    plusplus
    -- Tests for failure of ++ on non-int/float

    univ1
    -- Tests failure for calling a class method with an instance

    univ2
    -- Tests failure for calling an instance method with a class name
    

passing tests:
    assign-and-access:
    -- Declare, assign, and print a string variable in three separate statements 

    assign1:
    -- Declare and assign an int variable in two separate statements
    
    assign2:
    -- Declare and assign a string variable in two separate statements

    classvar-local-assign
    -- Declare a class in a local variable and assign its member variable

    decl-assign
    -- Assign a local string variable and print it
    
    doubleop
    -- Tests unary operators ++ and -- on ints and floats

    fcall-inherited
    -- Tests calling a function that has been inherited

    fcall-noarg
    -- Tests a function call of a func with no arguments

    fcall-overwritten
    -- Tests a function call of a func that has been overrided
    
    fcall-returnlocal
    -- Tests a function call that returns a locally declared value in the function

    fcall-witharg
    -- Test function calls with arguments

    fcall-withinclass
    -- Tests calling a function with a func call of a func within a class

    float
    -- Test float literals
    
    hello-world;
    -- Print out the string "Hello world!" using Olympus.print printing function

    if1
    -- Test true case of if (no else) 

    if2
    -- Test true case of if-else statement 

    if3
    -- Test false case of if-else statement

    inherit-memvar
    -- Test inheritance of member variables and their assignment 

    lits1:
    -- Declare and assign int, bool, and string locals in main(declaration and assign are on 2 lines)
    
    local-main:
    -- Declare a local variable in main

    main-classinst:
    -- Declare an instance of a class in main

    main-inst-mem-assign:
    -- Assign a value to a public member variable in a class instance

    main-return-new
    -- Tests returning a new object

    mismatch-return
    -- Tests returning a descendant of a class into a declared class variable (e.g. Animal a = new Dog;)
    
    opassign
    -- Tests op assign on ints and floats

    print-classvar:
    -- Access a public string class variable in a call to Olympus.print

    prints
    -- Tests print, println, printerr, and printi, our built-in print functions

    sub-ints
    -- Tests adding ints and assigning to variables or class vars

    univ1
    -- Tests calling a class method 

    univ2
    -- Tests calling an instance method

    unop1
    -- Test unop (!) on bool declaration and assignment, and isolated assignment
    and (-) on int/float declaration and assignment, and isolated assignment

    while-counter
    -- Tests while loop with a counter
    
    while
    -- Tests simple while loop


# What has been implemented

We've implemented classes and related features, such as polymorphism, dynamic 
dispatch of methods in the polymorphic case (e.g. `Animal a = new Dog()` where 
`a` calls a Dog-specific function), the inheritance of member variables and 
functions, overloading of methods by child classes, and `univ` methods. This 
involves semantic checking of methods, inheritance, and public and private 
encapsulation levels, since those can be checked at compile-time. We have also 
implemented runtime checking of permitted functions and member variables to 
disallow non-permitted classes, as, due to the polymorphic case, we cannot do
this at compile-time.

Although they were included in our original proposal, we have not implemented 
Lists. This has been updated in our final Language reference manual.